### Вариант ЛБ: Поиск в лабиринте

Лабиринт состоит из входа, выхода (они единственны) и комнат, соединенных проходами.
При записи лабиринта его комнаты идентифицируются номерами, вход и выход обозначаются
знаками IN и OUT, и указываются все пары комнат, соединенных проходом. Предполагается,
что лабиринт проходим, т.е. существует хотя бы один путь по проходам лабиринта,
соединяющий его вход и выход.

Определить, можно ли засыпать какой-нибудь один проход между комнатами заданного
лабиринта так, чтобы лабиринт стал непроходимым (т.е нет пути от входа до выхода).
Засыпать два прохода? Найти все такие варианты превратить лабиринт в непроходимый.

### Почему для решения задачи выбран язык Prolog?

Решение задачи поиска пути в лабиринте в любом случае будет сводится к перебору всех путей. Подобное решение наиболее лакончно будет выглядеть на языке Prolog, так как в нем из коробки реализован бэктрекинг. На логических или императивных языках задачу, естественно, можно решить, но решение будет сложнее. 

### Описание запуска

Чтобы запустить интерпретатор SWI-Prolog с предзагруженными предикатами:
```
make run
```

Далее в интерпретаторе SWI-Prolog можно вводить команды для поиска пути:

```
?- solve_maze(
    [tr(1, 2), tr(in, 1), tr(in, 3), tr(2, 4), tr(1, 3), tr(4, 5), tr(5, out)],
    Path
).
Path = [in, 3, 1, 2, 4, 5, out] ;
Path = [in, 1, 2, 4, 5, out] ;
false.
```
